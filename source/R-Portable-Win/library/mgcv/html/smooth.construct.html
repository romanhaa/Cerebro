<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Constructor functions for smooth terms in a GAM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for smooth.construct {mgcv}"><tr><td>smooth.construct {mgcv}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Constructor functions for smooth terms in a GAM</h2>

<h3>Description</h3>

<p>Smooth terms in a GAM formula are turned into smooth specification objects of 
class <code>xx.smooth.spec</code> during processing of the formula. Each of these objects is
converted to a smooth object using an appropriate <code>smooth.construct</code> function. New smooth classes 
can be added by writing a new <code>smooth.construct</code> method function and a corresponding 
<code><a href="Predict.matrix.html">Predict.matrix</a></code> method function (see example code below).
</p>
<p>In practice, <code>smooth.construct</code> is usually called via <code>smooth.construct2</code> and the wrapper
function <code><a href="smoothCon.html">smoothCon</a></code>, in order to handle <code>by</code> variables and
centering constraints (see the <code><a href="smoothCon.html">smoothCon</a></code> documentation if 
you need to handle these things directly, for a user defined smooth class).
</p>


<h3>Usage</h3>

<pre>
smooth.construct(object,data,knots)
smooth.construct2(object,data,knots)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p> is a smooth specification object, generated by an <code><a href="s.html">s</a></code> or <code><a href="te.html">te</a></code> term in a GAM 
formula. Objects generated by <code>s</code> terms have class <code>xx.smooth.spec</code> where <code>xx</code> is given by the 
<code>bs</code> argument of <code>s</code> (this convention allows the user to add their own smoothers). 
If <code>object</code> is not class <code>tensor.smooth.spec</code> it will have the following elements:
</p>

<dl>
<dt>term</dt><dd><p>The names of the covariates for this smooth, in an array.</p>
</dd>
<dt>bs.dim</dt><dd><p> Argument <code>k</code> of the <code>s</code> term generating the object. This is the dimension of the basis 
used to represent the term (or, arguably, 1 greater than the basis dimension for <code>cc</code> terms). 
<code>bs.dim&lt;0</code> indicates that the constructor should set this to the default value.</p>
</dd>
<dt>fixed</dt><dd><p><code>TRUE</code> if the term is to be unpenalized, otherwise <code>FALSE</code>.</p>
</dd>
<dt>dim</dt><dd><p>the number covariates of which this smooth is a function.</p>
</dd>
<dt>p.order</dt><dd><p>the order of the smoothness penalty or <code>NA</code> for autoselection of this. This is argument 
<code>m</code> of the <code>s</code> term that generated <code>object</code>.</p>
</dd>
<dt>by</dt><dd><p>the name of any <code>by</code> variable to multiply this term as supplied as an argument to <code>s</code>. 
<code>"NA"</code> if there is no such term.</p>
</dd>
<dt>label</dt><dd><p>A suitable label for use with this term.</p>
</dd>
<dt>xt</dt><dd><p>An object containing information that may be needed for basis setup
(used, e.g. by <code>"tp"</code> smooths to pass optional information on big dataset
handling).</p>
</dd>
<dt>id</dt><dd><p>Any identity associated with this term &mdash; used for linking bases
and smoothing parameters. <code>NULL</code> by default, indicating no linkage.</p>
</dd>
<dt>sp</dt><dd><p>Smoothing parameters for the term. Any negative are estimated,
otherwise they are fixed at the supplied value. Unless <code>NULL</code> (default),
over-rides <code>sp</code> argument to <code><a href="gam.html">gam</a></code>.</p>
</dd>
</dl>

<p>If <code>object</code> is of class <code>tensor.smooth.spec</code> then it was generated by a <code>te</code> term in the GAM formula, 
and specifies a smooth of several variables with a basis generated as a tensor product of lower dimensional bases. 
In this case the object will be different and will have the following elements:
</p>

<dl>
<dt>margin</dt><dd><p>is a list of smooth specification objects of the type listed above, defining the bases which have 
their tensor product formed in order to construct this term.</p>
</dd>
<dt>term</dt><dd><p>is the array of names of the covariates that are arguments of the smooth.</p>
</dd>
<dt>by</dt><dd><p>is the name of any <code>by</code> variable, or <code>"NA"</code>.</p>
</dd>
<dt>fx</dt><dd><p>is an array, the elements of which indicate whether (<code>TRUE</code>) any of the margins in the 
tensor product should be unpenalized.</p>
</dd>
<dt>label</dt><dd><p>A suitable label for use with this term.</p>
</dd>
<dt>dim</dt><dd><p>is the number of covariates of which this smooth is a function.</p>
</dd>
<dt>mp</dt><dd><p><code>TRUE</code> if multiple penalties are to be used.</p>
</dd>
<dt>np</dt><dd><p><code>TRUE</code> if 1-D marginal smooths are to be re-parameterized in terms of
function values.</p>
</dd>
<dt>id</dt><dd><p>Any identity associated with this term &mdash; used for linking bases
and smoothing parameters. <code>NULL</code> by default, indicating no linkage.</p>
</dd>
<dt>sp</dt><dd><p>Smoothing parameters for the term. Any negative are estimated,
otherwise they are fixed at the supplied value. Unless <code>NULL</code> (default),
over-rides <code>sp</code> argument to <code><a href="gam.html">gam</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
<p>For <code>smooth.construct</code> a data frame or list containing the evaluation of the elements of <code>object$term</code>,
with names given by <code>object$term</code>. The last entry will be the <code>by</code> variable, if <code>object$by</code>
is not <code>"NA"</code>. For <code>smooth.construct2</code> <code>data</code> need only be an object within which <code>object$term</code> 
can be evaluated, the variables can be in any order, and there can be irrelevant variables present as well. </p>
</td></tr>
<tr valign="top"><td><code>knots</code></td>
<td>
<p>an optional data frame or list containing the knots relating to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically. The structure of <code>knots</code> should
be as for <code>data</code>, depending on whether <code>smooth.construct</code> or <code>smooth.construct2</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> There are built in methods for objects with the following classes:
<code>tp.smooth.spec</code> (thin plate regression splines: see <code><a href="smooth.construct.tp.smooth.spec.html">tprs</a></code>); 
<code>ts.smooth.spec</code> (thin plate regression splines with shrinkage-to-zero);
<code>cr.smooth.spec</code> (cubic regression splines: see <code><a href="smooth.construct.cr.smooth.spec.html">cubic.regression.spline</a></code>;
<code>cs.smooth.spec</code> (cubic regression splines with shrinkage-to-zero);
<code>cc.smooth.spec</code> (cyclic cubic regression splines);
<code>ps.smooth.spec</code> (Eilers and Marx (1986) style P-splines: see <code><a href="smooth.construct.ps.smooth.spec.html">p.spline</a></code>);
<code>cp.smooth.spec</code> (cyclic P-splines);
<code>ad.smooth.spec</code> (adaptive smooths of 1 or 2 variables: see <code><a href="smooth.construct.ad.smooth.spec.html">adaptive.smooth</a></code>);
<code>re.smooth.spec</code> (simple random effect terms);
<code>mrf.smooth.spec</code> (Markov random field smoothers for smoothing over discrete districts);
<code>tensor.smooth.spec</code> (tensor product smooths).
</p>
<p>There is an implicit assumption that the basis only depends on the knots and/or the set of unique 
covariate combinations; i.e. that the basis is the same whether generated from
the full set of covariates, or just the unique combinations of covariates. 
</p>
<p>Plotting of smooths is handled by plot methods for smooth objects. A default <code>mgcv.smooth</code> method 
is used if there is no more specific method available. Plot methods can be added for specific smooth classes, see 
source code for <code>mgcv:::plot.sos.smooth</code>, <code>mgcv:::plot.random.effect</code>, <code>mgcv:::plot.mgcv.smooth</code> 
for example code.
</p>


<h3>Value</h3>

<p>The input argument <code>object</code>, assigned a new class to indicate what type of smooth it is and with at least the 
following items added:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>The model matrix from this term. This may have an <code>"offset"</code>
attribute:  a vector of length <code>nrow(X)</code> containing any contribution of
the smooth to the model offset term. <code>by</code> variables do not need to be
dealt with here, but if they are then an item <code>by.done</code> must be added to
the <code>object</code>.</p>
</td></tr>
<tr valign="top"><td><code>S</code></td>
<td>
<p>A list of positive semi-definite penalty matrices that apply to this term. The list will be empty 
if the term is to be left un-penalized.</p>
</td></tr>
<tr valign="top"><td><code>rank</code></td>
<td>
<p>An array giving the ranks of the penalties.</p>
</td></tr>
<tr valign="top"><td><code>null.space.dim</code></td>
<td>
<p>The dimension of the penalty null space (before centering).</p>
</td></tr>
</table>
<p>The following items may be added:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>C</code></td>
<td>
<p>The matrix defining any identifiability constraints on the term, for use when fitting. If this is <code>NULL</code> then
<code>smoothCon</code> will add an identifiability constraint that each term should
sum to zero over the covariate values. Set to a zero row matrix if no
constraints are required. If a supplied <code>C</code> has an attribute <code>"always.apply"</code> then it is never ignored, even if any
<code>by</code> variables of a smooth imply that no constraint is actually needed. Code for creating <code>C</code> should check whether 
the specification object already contains a zero row matrix, and leave this unchanged if it is (since this signifies 
no constraint should be produced). </p>
</td></tr>
<tr valign="top"><td><code>Cp</code></td>
<td>
<p>An optional matrix supplying alternative identifiability constraints for use when predicting. By default the 
fitting constrants are used. This option is useful when some sort of simple sparse constraint is required for fitting, but the 
usual sum-to-zero constraint is required for prediction so that, e.g. the CIs for model components are as narrow as possible. </p>
</td></tr>
<tr valign="top"><td><code>no.rescale</code></td>
<td>
<p>if this is non-NULL then the penalty coefficient matrix of the smooth will not be 
rescaled for enhaced numerical stability (rescaling is the default, because <code><a href="gamm.html">gamm</a></code> requires it). 
Turning off rescaling is useful if the values of the smoothing parameters should be interpretable in a model, 
for example because they are inverse variance components.  </p>
</td></tr>
<tr valign="top"><td><code>df</code></td>
<td>
<p>the degrees of freedom associated with this term (when
unpenalized and unconstrained). If this is null then <code>smoothCon</code> will set it to the basis 
dimension. <code>smoothCon</code> will reduce this by the number of constraints.</p>
</td></tr>
<tr valign="top"><td><code>te.ok</code></td>
<td>
<p><code>0</code> if this term should not be used as a tensor product marginal, <code>1</code> if 
it can be used and plotted, and <code>2</code> is it can be used but not plotted. Set to <code>1</code> if <code>NULL</code>.</p>
</td></tr>
<tr valign="top"><td><code>plot.me</code></td>
<td>
<p>Set to <code>FALSE</code> if this smooth should not be plotted by <code><a href="plot.gam.html">plot.gam</a></code>.  Set to <code>TRUE</code> if <code>NULL</code>.</p>
</td></tr>
<tr valign="top"><td><code>side.constrain</code></td>
<td>
<p>Set to <code>FALSE</code> to ensure that the smooth is never subject to side constraints as a result of nesting. </p>
</td></tr>
<tr valign="top"><td><code>L</code></td>
<td>
<p>smooths may depend on fewer &lsquo;underlying&rsquo; smoothing parameters than there are elements of
<code>S</code>. In this case <code>L</code> is the matrix mapping the vector of underlying log smoothing 
parameters to the vector of logs of the smoothing parameters actually multiplying the <code>S[[i]]</code>. 
<code>L=NULL</code> signifies that there is one smoothing parameter per <code>S[[i]]</code>. </p>
</td></tr>
</table>
<p>Usually the returned object will also include extra information required to define the basis, and used by 
<code><a href="Predict.matrix.html">Predict.matrix</a></code> methods to make predictions using the basis. See
the <code>Details</code> section for links to the information included for the built in smooth classes. 
</p>
<p><code>tensor.smooth</code> returned objects will additionally have each element of
the <code>margin</code> list updated in the same way. <code>tensor.smooths</code> also
have a list, <code>XP</code>, containing re-parameterization matrices for any 1-D marginal terms
re-parameterized in terms of function values. This list will have <code>NULL</code>
entries for marginal smooths that are not re-parameterized, and is only long
enough to reach the last re-parameterized marginal in the list.  
</p>


<h3>WARNING</h3>

<p>User defined smooth objects should avoid having attributes names
<code>"qrc"</code> or <code>"nCons"</code> as these are used internally to provide
constraint free parameterizations.</p>


<h3>Author(s)</h3>

<p>Simon N. Wood <a href="mailto:simon.wood@r-project.org">simon.wood@r-project.org</a></p>


<h3>References</h3>

 
<p>Wood, S.N. (2003) Thin plate regression splines. J.R.Statist.Soc.B 65(1):95-114
</p>
<p>Wood, S.N. (2006) Low rank scale invariant tensor product smooths for
generalized additive mixed models. Biometrics 62(4):1025-1036
</p>
<p>The code given in the example is based on the smooths advocated in:
</p>
<p>Ruppert, D., M.P. Wand and R.J. Carroll (2003) Semiparametric Regression. Cambridge 
University Press.
</p>
<p>However if you want p-splines, rather than splines with derivative based penalties,
then the built in &quot;ps&quot; class is probably a marginally better bet. It's based on
</p>
<p>Eilers, P.H.C. and B.D. Marx (1996) Flexible Smoothing with B-splines and Penalties. 
Statistical Science, 11(2):89-121
</p>
<p><a href="http://www.maths.bris.ac.uk/~sw15190/">http://www.maths.bris.ac.uk/~sw15190/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="s.html">s</a></code>,<code><a href="get.var.html">get.var</a></code>, <code><a href="gamm.html">gamm</a></code>, <code><a href="gam.html">gam</a></code>,
<code><a href="Predict.matrix.html">Predict.matrix</a></code>,
<code><a href="smoothCon.html">smoothCon</a></code>, <code><a href="smoothCon.html">PredictMat</a></code>
</p>


<h3>Examples</h3>

<pre>
## Adding a penalized truncated power basis class and methods
## as favoured by Ruppert, Wand and Carroll (2003) 
## Semiparametric regression CUP. (No advantage to actually
## using this, since mgcv can happily handle non-identity 
## penalties.)

smooth.construct.tr.smooth.spec&lt;-function(object,data,knots)
## a truncated power spline constructor method function
## object$p.order = null space dimension
{ m &lt;- object$p.order[1]
  if (is.na(m)) m &lt;- 2 ## default 
  if (m&lt;1) stop("silly m supplied")
  if (object$bs.dim&lt;0) object$bs.dim &lt;- 10 ## default
  nk&lt;-object$bs.dim-m-1 ## number of knots
  if (nk&lt;=0) stop("k too small for m")
  x &lt;- data[[object$term]]  ## the data
  x.shift &lt;- mean(x) # shift used to enhance stability
  k &lt;- knots[[object$term]] ## will be NULL if none supplied
  if (is.null(k)) # space knots through data
  { n&lt;-length(x)
    k&lt;-quantile(x[2:(n-1)],seq(0,1,length=nk+2))[2:(nk+1)]
  }
  if (length(k)!=nk) # right number of knots?
  stop(paste("there should be ",nk," supplied knots"))
  x &lt;- x - x.shift # basis stabilizing shift
  k &lt;- k - x.shift # knots treated the same!
  X&lt;-matrix(0,length(x),object$bs.dim)
  for (i in 1:(m+1)) X[,i] &lt;- x^(i-1)
  for (i in 1:nk) X[,i+m+1]&lt;-(x-k[i])^m*as.numeric(x&gt;k[i])
  object$X&lt;-X # the finished model matrix
  if (!object$fixed) # create the penalty matrix
  { object$S[[1]]&lt;-diag(c(rep(0,m+1),rep(1,nk)))
  }
  object$rank&lt;-nk  # penalty rank
  object$null.space.dim &lt;- m+1  # dim. of unpenalized space
  ## store "tr" specific stuff ...
  object$knots&lt;-k;object$m&lt;-m;object$x.shift &lt;- x.shift
 
  object$df&lt;-ncol(object$X)     # maximum DoF (if unconstrained)
 
  class(object)&lt;-"tr.smooth"  # Give object a class
  object
}

Predict.matrix.tr.smooth&lt;-function(object,data)
## prediction method function for the `tr' smooth class
{ x &lt;- data[[object$term]]
  x &lt;- x - object$x.shift # stabilizing shift
  m &lt;- object$m;     # spline order (3=cubic)
  k&lt;-object$knots    # knot locations
  nk&lt;-length(k)      # number of knots
  X&lt;-matrix(0,length(x),object$bs.dim)
  for (i in 1:(m+1)) X[,i] &lt;- x^(i-1)
  for (i in 1:nk) X[,i+m+1] &lt;- (x-k[i])^m*as.numeric(x&gt;k[i])
  X # return the prediction matrix
}

# an example, using the new class....
require(mgcv)
set.seed(100)
dat &lt;- gamSim(1,n=400,scale=2)
b&lt;-gam(y~s(x0,bs="tr",m=2)+s(x1,bs="ps",m=c(1,3))+
         s(x2,bs="tr",m=3)+s(x3,bs="tr",m=2),data=dat)
plot(b,pages=1)
b&lt;-gamm(y~s(x0,bs="tr",m=2)+s(x1,bs="ps",m=c(1,3))+
         s(x2,bs="tr",m=3)+s(x3,bs="tr",m=2),data=dat)
plot(b$gam,pages=1)
# another example using tensor products of the new class
dat &lt;- gamSim(2,n=400,scale=.1)$data
b &lt;- gam(y~te(x,z,bs=c("tr","tr"),m=c(2,2)),data=dat)
vis.gam(b)
</pre>

<hr /><div style="text-align: center;">[Package <em>mgcv</em> version 1.8-24 <a href="00Index.html">Index</a>]</div>
</body></html>
