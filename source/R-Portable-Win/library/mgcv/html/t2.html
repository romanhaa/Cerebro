<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Define alternative tensor product smooths in GAM formulae</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for t2 {mgcv}"><tr><td>t2 {mgcv}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Define alternative tensor product smooths in GAM formulae</h2>

<h3>Description</h3>

<p> Alternative to <code><a href="te.html">te</a></code> for defining tensor product smooths
in a <code><a href="gam.html">gam</a></code> formula. Results in a construction in which the penalties are 
non-overlapping multiples of identity matrices (with some rows and columns zeroed). 
The construction, which is due to Fabian Scheipl (<code>mgcv</code> implementation, 2010), is analogous to Smoothing Spline ANOVA 
(Gu, 2002), but using low rank penalized regression spline marginals. The main advantage of this construction 
is that it is useable with <code>gamm4</code> from package <code>gamm4</code>.
</p>


<h3>Usage</h3>

<pre>t2(..., k=NA,bs="cr",m=NA,d=NA,by=NA,xt=NULL,
               id=NULL,sp=NULL,full=FALSE,ord=NULL,pc=NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>...</code></td>
<td>
<p> a list of variables that are the covariates that this
smooth is a function of.  Transformations whose form depends on
the values of the data are best avoided here: e.g. <code>t2(log(x),z)</code>
is fine, but <code>t2(I(x/sd(x)),z)</code> is not (see <code><a href="predict.gam.html">predict.gam</a></code>).</p>
</td></tr>
<tr valign="top"><td><code>k</code></td>
<td>
<p> the dimension(s) of the bases used to represent the smooth term.
If not supplied then set to <code>5^d</code>. If supplied as a single number then this 
basis dimension is used for each basis. If supplied as an array then the elements are
the dimensions of the component (marginal) bases of the tensor
product. See <code><a href="choose.k.html">choose.k</a></code> for further information.</p>
</td></tr>
<tr valign="top"><td><code>bs</code></td>
<td>
<p>array (or single character string) specifying the type for each 
marginal basis. <code>"cr"</code> for cubic regression spline; <code>"cs"</code> for cubic
regression spline with shrinkage; <code>"cc"</code> for periodic/cyclic 
cubic regression spline; <code>"tp"</code> for thin plate regression spline;
<code>"ts"</code> for t.p.r.s. with extra shrinkage. See <code><a href="smooth.terms.html">smooth.terms</a></code> for details 
and full list. User defined bases can 
also be used here (see <code><a href="smooth.construct.html">smooth.construct</a></code> for an example). If only one 
basis code is given then this is used for all bases.</p>
</td></tr>
<tr valign="top"><td><code>m</code></td>
<td>
<p>The order of the spline and its penalty (for smooth classes that use this) for each term. 
If a single number is given  then it is used for all terms. A vector can be used to 
supply a different <code>m</code> for each margin. For marginals that take vector <code>m</code> 
(e.g. <code><a href="smooth.construct.ps.smooth.spec.html">p.spline</a></code> and <code><a href="smooth.construct.ds.smooth.spec.html">Duchon.spline</a></code>), then
a list can be supplied, with a vector element for each margin. <code>NA</code> autoinitializes. 
<code>m</code> is ignored by some bases (e.g. <code>"cr"</code>).</p>
</td></tr>
<tr valign="top"><td><code>d</code></td>
<td>
<p>array of marginal basis dimensions. For example if you want a smooth for 3 covariates 
made up of a tensor product of a 2 dimensional t.p.r.s. basis and a 1-dimensional basis, then 
set <code>d=c(2,1)</code>. Incompatibilities between built in basis types and dimension will be
resolved by resetting the basis type.</p>
</td></tr>
<tr valign="top"><td><code>by</code></td>
<td>
<p>a numeric or factor variable of the same dimension as each covariate. 
In the numeric vector case the elements multiply the smooth evaluated at the corresponding 
covariate values (a &lsquo;varying coefficient model&rsquo; results). 
In the factor case causes a replicate of the smooth to be produced for
each factor level. See <code><a href="gam.models.html">gam.models</a></code> for further details. May also be a matrix 
if covariates are matrices: in this case implements linear functional of a smooth 
(see <code><a href="gam.models.html">gam.models</a></code> and <code><a href="linear.functional.terms.html">linear.functional.terms</a></code> for details).</p>
</td></tr>
<tr valign="top"><td><code>xt</code></td>
<td>
<p>Either a single object, providing any extra information to be passed
to each marginal basis constructor, or a list of such objects, one for each
marginal basis. </p>
</td></tr>
<tr valign="top"><td><code>id</code></td>
<td>
<p>A label or integer identifying this term in order to link its smoothing
parameters to others of the same type. If two or more smooth terms have the same 
<code>id</code> then they will have the same smoothing paramsters, and, by default,
the same bases (first occurance defines basis type, but data from all terms 
used in basis construction).</p>
</td></tr>
<tr valign="top"><td><code>sp</code></td>
<td>
<p>any supplied smoothing parameters for this term. Must be an array of the same
length as the number of penalties for this smooth. Positive or zero elements are taken as fixed 
smoothing parameters. Negative elements signal auto-initialization. Over-rides values supplied in 
<code>sp</code> argument to <code><a href="gam.html">gam</a></code>. Ignored by <code>gamm</code>.</p>
</td></tr>
<tr valign="top"><td><code>full</code></td>
<td>
<p>If <code>TRUE</code> then there is a separate penalty for each combination of null space column 
and range space. This gives strict invariance. If <code>FALSE</code> each combination of null space and 
range space generates one penalty, but the coulmns of each null space basis are treated as one group. 
The latter is more parsimonious, but does mean that invariance is only 
achieved by an arbitrary rescaling of null space basis vectors.</p>
</td></tr>
<tr valign="top"><td><code>ord</code></td>
<td>
<p>an array giving the orders of terms to retain. Here order means number of marginal range spaces
used in the construction of the component. <code>NULL</code> to retain everything. </p>
</td></tr>
<tr valign="top"><td><code>pc</code></td>
<td>
<p>If not <code>NULL</code>, signals a point constraint: the smooth should pass through zero at the
point given here (as a vector or list with names corresponding to the smooth names). Never ignored
if supplied. See <code><a href="identifiability.html">identifiability</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p> Smooths of several covariates can be constructed from tensor products of the bases
used to represent smooths of one (or sometimes more) of the covariates. To do this &lsquo;marginal&rsquo; bases
are produced with associated model matrices and penalty matrices. These are reparameterized so that the 
penalty is zero everywhere, except for some elements on the leading diagonal, which all have the same non-zero value. 
This reparameterization results in an unpenalized and a penalized subset of parameters, for each marginal basis (see 
e.g. appendix of Wood, 2004, for details).
</p>
<p>The re-parameterized marginal bases are then combined to produce a basis for a single function of all the covariates 
(dimension given by the product of the dimensions of the marginal bases). In this set up there are multiple 
penalty matrices &mdash; all zero, but for a mixture of a constant and zeros on the leading diagonal. No two penalties have 
a non-zero entry in the same place. 
</p>
<p>Essentially the basis for the tensor product can be thought of as being constructed from a set of
products of the penalized (range) or unpenalized (null) space bases of the marginal smooths  (see Gu, 2002, section 2.4). 
To construct one of the set, choose either the 
null space or the range space from each marginal, and from these bases construct a product basis. The result is subject to a ridge 
penalty (unless it happens to be a product entirely of marginal null spaces). The whole basis for the smooth is constructed from 
all the different product bases that can be constructed in this way. The separately penalized components of the smooth basis each
have an interpretation in terms of the ANOVA - decomposition of the term. 
See <code><a href="pen.edf.html">pen.edf</a></code> for some further information.
</p>
<p>Note that there are two ways to construct the product. When <code>full=FALSE</code> then the null space bases are treated as a whole in each product,
but when <code>full=TRUE</code> each null space column is treated as a separate null space. The latter results in more penalties, but is the strict 
analog of the SS-ANOVA approach.
</p>
<p>Tensor product smooths are especially useful for representing functions of covariates measured in different units, 
although they are typically not quite as nicely behaved as t.p.r.s. smooths for well scaled covariates.
</p>
<p>Note also that GAMs constructed from lower rank tensor product smooths are
nested within GAMs constructed from higher rank tensor product smooths if the
same marginal bases are used in both cases (the marginal smooths themselves
are just special cases of tensor product smooths.)
</p>
<p>Note that tensor product smooths should not be centred (have identifiability constraints imposed) 
if any marginals would not need centering. The constructor for tensor product smooths 
ensures that this happens.
</p>
<p>The function does not evaluate the variable arguments.
</p>


<h3>Value</h3>

<p> A class <code>t2.smooth.spec</code> object defining a tensor product smooth
to be turned into a basis and penalties by the <code>smooth.construct.tensor.smooth.spec</code> function. 
</p>
<p>The returned object contains the following items:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>margin</code></td>
<td>
<p>A list of <code>smooth.spec</code> objects of the type returned by <code><a href="s.html">s</a></code>, 
defining the basis from which the tensor product smooth is constructed.</p>
</td></tr>
<tr valign="top"><td><code>term</code></td>
<td>
<p>An array of text strings giving the names of the covariates that 
the term is a function of.</p>
</td></tr>
<tr valign="top"><td><code>by</code></td>
<td>
<p>is the name of any <code>by</code> variable as text (<code>"NA"</code> for none).</p>
</td></tr>
<tr valign="top"><td><code>fx</code></td>
<td>
<p> logical array with element for each penalty of the term
(tensor product smooths have multiple penalties). <code>TRUE</code> if the penalty is to 
be ignored, <code>FALSE</code>, otherwise. </p>
</td></tr>
<tr valign="top"><td><code>label</code></td>
<td>
<p>A suitable text label for this smooth term.</p>
</td></tr>
<tr valign="top"><td><code>dim</code></td>
<td>
<p>The dimension of the smoother - i.e. the number of
covariates that it is a function of.</p>
</td></tr>
<tr valign="top"><td><code>mp</code></td>
<td>
<p><code>TRUE</code> is multiple penalties are to be used (default).</p>
</td></tr>
<tr valign="top"><td><code>np</code></td>
<td>
<p><code>TRUE</code> to re-parameterize 1-D marginal smooths in terms of function
values (defualt).</p>
</td></tr>
<tr valign="top"><td><code>id</code></td>
<td>
<p>the <code>id</code> argument supplied to <code>te</code>.</p>
</td></tr>
<tr valign="top"><td><code>sp</code></td>
<td>
<p>the <code>sp</code> argument supplied to <code>te</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Simon N. Wood <a href="mailto:simon.wood@r-project.org">simon.wood@r-project.org</a> and Fabian Scheipl</p>


<h3>References</h3>

<p>Wood S.N., F. Scheipl and J.J. Faraway (2013, online Feb 2012) Straightforward intermediate rank tensor product smoothing in mixed models. Statistical Computing. 23(3):341-360
</p>
<p>Gu, C. (2002) Smoothing Spline ANOVA, Springer.
</p>
<p>Alternative approaches to functional ANOVA decompositions, 
*not* implemented by t2 terms, are discussed in:
</p>
<p>Belitz and Lang (2008) Simultaneous selection of variables and smoothing parameters in structured additive regression models. Computational Statistics &amp; Data Analysis, 53(1):61-81
</p>
<p>Lee, D-J and M. Durban (2011) P-spline ANOVA type interaction models for spatio-temporal smoothing. Statistical Modelling, 11:49-69
</p>
<p>Wood, S.N. (2006) Low-Rank Scale-Invariant Tensor Product Smooths for Generalized Additive Mixed Models. Biometrics 62(4): 1025-1036.
</p>


<h3>See Also</h3>

<p><code><a href="te.html">te</a></code> <code><a href="s.html">s</a></code>,<code><a href="gam.html">gam</a></code>,<code><a href="gamm.html">gamm</a></code>, 
</p>


<h3>Examples</h3>

<pre>

# following shows how tensor product deals nicely with 
# badly scaled covariates (range of x 5% of range of z )
require(mgcv)
test1&lt;-function(x,z,sx=0.3,sz=0.4)  
{ x&lt;-x*20
  (pi**sx*sz)*(1.2*exp(-(x-0.2)^2/sx^2-(z-0.3)^2/sz^2)+
  0.8*exp(-(x-0.7)^2/sx^2-(z-0.8)^2/sz^2))
}
n&lt;-500
old.par&lt;-par(mfrow=c(2,2))
x&lt;-runif(n)/20;z&lt;-runif(n);
xs&lt;-seq(0,1,length=30)/20;zs&lt;-seq(0,1,length=30)
pr&lt;-data.frame(x=rep(xs,30),z=rep(zs,rep(30,30)))
truth&lt;-matrix(test1(pr$x,pr$z),30,30)
f &lt;- test1(x,z)
y &lt;- f + rnorm(n)*0.2
b1&lt;-gam(y~s(x,z))
persp(xs,zs,truth);title("truth")
vis.gam(b1);title("t.p.r.s")
b2&lt;-gam(y~t2(x,z))
vis.gam(b2);title("tensor product")
b3&lt;-gam(y~t2(x,z,bs=c("tp","tp")))
vis.gam(b3);title("tensor product")
par(old.par)

test2&lt;-function(u,v,w,sv=0.3,sw=0.4)  
{ ((pi**sv*sw)*(1.2*exp(-(v-0.2)^2/sv^2-(w-0.3)^2/sw^2)+
  0.8*exp(-(v-0.7)^2/sv^2-(w-0.8)^2/sw^2)))*(u-0.5)^2*20
}
n &lt;- 500
v &lt;- runif(n);w&lt;-runif(n);u&lt;-runif(n)
f &lt;- test2(u,v,w)
y &lt;- f + rnorm(n)*0.2

## tensor product of 2D Duchon spline and 1D cr spline
m &lt;- list(c(1,.5),0)
b &lt;- gam(y~t2(v,w,u,k=c(30,5),d=c(2,1),bs=c("ds","cr"),m=m))

## look at the edf per penalty. "rr" denotes interaction term 
## (range space range space). "rn" is interaction of null space
## for u with range space for v,w...
pen.edf(b) 

## plot results...
op &lt;- par(mfrow=c(2,2))
vis.gam(b,cond=list(u=0),color="heat",zlim=c(-0.2,3.5))
vis.gam(b,cond=list(u=.33),color="heat",zlim=c(-0.2,3.5))
vis.gam(b,cond=list(u=.67),color="heat",zlim=c(-0.2,3.5))
vis.gam(b,cond=list(u=1),color="heat",zlim=c(-0.2,3.5))
par(op)

b &lt;- gam(y~t2(v,w,u,k=c(25,5),d=c(2,1),bs=c("tp","cr"),full=TRUE),
         method="ML")
## more penalties now. numbers in labels like "r1" indicate which 
## basis function of a null space is involved in the term. 
pen.edf(b) 

</pre>

<hr /><div style="text-align: center;">[Package <em>mgcv</em> version 1.8-24 <a href="00Index.html">Index</a>]</div>
</body></html>
